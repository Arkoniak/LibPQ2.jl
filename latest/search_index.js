var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#LibPQ-1",
    "page": "Home",
    "title": "LibPQ",
    "category": "section",
    "text": "(Image: Stable) (Image: Latest) (Image: Build Status) (Image: CodeCov)"
},

{
    "location": "index.html#Examples-1",
    "page": "Home",
    "title": "Examples",
    "category": "section",
    "text": ""
},

{
    "location": "index.html#Selection-1",
    "page": "Home",
    "title": "Selection",
    "category": "section",
    "text": "conn = Connection(\"dbname=postgres\")\nresult = execute(conn, \"SELECT typname FROM pg_type WHERE oid = 16\")\ndata = Data.stream!(result, NamedTuple)\nclear!(result)\n\n# the same but with parameters\nresult = execute(conn, \"SELECT typname FROM pg_type WHERE oid = \\$1\", [\"16\"])\ndata = Data.stream!(result, NamedTuple)\nclear!(result)\n\n# the same but using `fetch!` to handle streaming and clearing\ndata = fetch!(NamedTuple, execute(conn, \"SELECT typname FROM pg_type WHERE oid = \\$1\", [\"16\"]))\n\nclose(conn)"
},

{
    "location": "index.html#Insertion-1",
    "page": "Home",
    "title": "Insertion",
    "category": "section",
    "text": "conn = Connection(\"dbname=postgres user=$DATABASE_USER\")\n\nresult = execute(conn, \"\"\"\n    CREATE TEMPORARY TABLE libpqjl_test (\n        no_nulls    varchar(10) PRIMARY KEY,\n        yes_nulls   varchar(10)\n    );\n\"\"\")\nclear!(result)\n\nData.stream!(\n    data,\n    Statement,\n    conn,\n    \"INSERT INTO libpqjl_test (no_nulls, yes_nulls) VALUES (\\$1, \\$2);\",\n)\n\nclose(conn)"
},

{
    "location": "pages/api.html#",
    "page": "API",
    "title": "API",
    "category": "page",
    "text": ""
},

{
    "location": "pages/api.html#LibPQ.Connection",
    "page": "API",
    "title": "LibPQ.Connection",
    "category": "Type",
    "text": "type Connection\n\nA connection to a PostgreSQL database.\n\nFields:\n\nconn\nA pointer to a libpq PGconn object (C_NULL if closed)\nencoding\nlibpq client encoding (string encoding of returned data)\nuid_counter\nInteger counter for generating connection-level unique identifiers\ntype_map\nConnection-level type correspondence map\nfunc_map\nConnection-level conversion functions\nclosed\nTrue if the connection is closed and the PGconn object has been cleaned up\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.Connection-Tuple{AbstractString}",
    "page": "API",
    "title": "LibPQ.Connection",
    "category": "Method",
    "text": "Connection(\n    str::AbstractString;\n    throw_error::Bool=true,\n    type_map::AbstractDict=LibPQ.PQTypeMap(),\n    conversions::AbstractDict=LibPQ.PQConversions(),\n) -> Connection\n\nCreate a Connection from a connection string as specified in the PostgreSQL documentation (33.1.1. Connection Strings).\n\nFor information on the type_map and conversions arguments, see Type Conversions.\n\nSee handle_new_connection for information on the throw_error argument.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.Result",
    "page": "API",
    "title": "LibPQ.Result",
    "category": "Type",
    "text": "type Result <: DataStreams.Data.Source\n\nA result from a PostgreSQL database query\n\nFields:\n\nresult\nA pointer to a libpq PGresult object (C_NULL if cleared)\ncleared\nTrue if the PGresult object has been cleaned up\ncolumn_oids\nPostgreSQL Oids for each column in the result\ncolumn_types\nJulia types for each column in the result\nnot_null\nWhether to expect NULL for each column (whether output data can have missing)\ncolumn_funcs\nConversions from PostgreSQL data to Julia types for each column in the result\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.Statement",
    "page": "API",
    "title": "LibPQ.Statement",
    "category": "Type",
    "text": "struct Statement\n\nA PostgreSQL prepared statement\n\nFields:\n\njl_conn\nA Connection for which this statement is valid. It may become invalid if the connection is reset.\n\nname\nAn autogenerated neame for the prepared statement (using unique_id\ndescription\nA Result containing a description of the prepared statement\nnum_params\nThe number of parameters accepted by this statement according to description\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_name-Tuple{LibPQ.Result,Integer}",
    "page": "API",
    "title": "LibPQ.column_name",
    "category": "Method",
    "text": "column_name(jl_result::Result, column_number::Integer) -> String\n\nReturn the name of the column at index column_number (1-based).\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_name-Tuple{LibPQ.Statement,Integer}",
    "page": "API",
    "title": "LibPQ.column_name",
    "category": "Method",
    "text": "column_name(stmt::Statement, column_number::Integer) -> String\n\nReturn the name of the column at index column_number (1-based) that would be returned by executing the prepared statement.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_names-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.column_names",
    "category": "Method",
    "text": "column_names(jl_result::Result) -> Vector{String}\n\nReturn the names of all the columns in the query result.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_names-Tuple{LibPQ.Statement}",
    "page": "API",
    "title": "LibPQ.column_names",
    "category": "Method",
    "text": "column_names(stmt::Statement) -> Vector{String}\n\nReturn the names of all the columns in the query result that would be returned by executing the prepared statement.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_number-Tuple{LibPQ.Result,Integer}",
    "page": "API",
    "title": "LibPQ.column_number",
    "category": "Method",
    "text": "column_number(jl_result::Result, column_idx::Integer) -> Int\n\nReturn the index of the column if it is valid, or error.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_number-Tuple{LibPQ.Result,Union{AbstractString, Symbol}}",
    "page": "API",
    "title": "LibPQ.column_number",
    "category": "Method",
    "text": "column_number(jl_result::Result, column_name::Union{AbstractString, Symbol}) -> Int\n\nReturn the index (1-based) of the column named column_name.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_number-Tuple{LibPQ.Statement,AbstractString}",
    "page": "API",
    "title": "LibPQ.column_number",
    "category": "Method",
    "text": "column_number(stmt::Statement, column_name::AbstractString) -> Int\n\nReturn the index (1-based) of the column named column_name that would be returned by executing the prepared statement.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.encoding-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.encoding",
    "category": "Method",
    "text": "encoding(jl_conn::Connection) -> String\n\nReturn the client encoding name for the current connection (see Table 23.1. PostgreSQL Character Sets for possible values).\n\nCurrently all Julia connections are set to use UTF8 as this makes conversion to and from String straighforward.\n\nSee also: set_encoding!, reset_encoding!\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.execute",
    "page": "API",
    "title": "LibPQ.execute",
    "category": "Function",
    "text": "execute(\n    {jl_conn::Connection, query::AbstractString | stmt::Statement},\n    [parameters::AbstractVector,]\n    throw_error::Bool=true,\n    column_types::AbstractDict=ColumnTypeMap(),\n    type_map::AbstractDict=LibPQ.PQTypeMap(),\n    conversions::AbstractDict=LibPQ.PQConversions(),\n) -> Result\n\nRun a query on the PostgreSQL database and return a Result. If throw_error is true, throw an error and clear the result if the query results in a fatal error or unreadable response.\n\nThe query may be passed as Connection and AbstractString (SQL) arguments, or as a Statement.\n\nexecute optionally takes a parameters vector which passes query parameters as strings to PostgreSQL.\n\ncolumn_types accepts type overrides for columns in the result which take priority over those in type_map. For information on the column_types, type_map, and conversions arguments, see Type Conversions.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.num_columns-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.num_columns",
    "category": "Method",
    "text": "num_columns(jl_result::Result) -> Int\n\nReturn the number of columns in the query result. This will be 0 if the query would never return data.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.num_columns-Tuple{LibPQ.Statement}",
    "page": "API",
    "title": "LibPQ.num_columns",
    "category": "Method",
    "text": "num_columns(stmt::Statement) -> Int\n\nReturn the number of columns that would be returned by executing the prepared statement.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.num_params-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.num_params",
    "category": "Method",
    "text": "num_params(jl_result::Result) -> Int\n\nReturn the number of parameters in a prepared statement. If this result did not come from the description of a prepared statement, return 0.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.num_params-Tuple{LibPQ.Statement}",
    "page": "API",
    "title": "LibPQ.num_params",
    "category": "Method",
    "text": "num_params(stmt::Statement) -> Int\n\nReturn the number of parameters in the prepared statement.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.num_rows-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.num_rows",
    "category": "Method",
    "text": "num_rows(jl_result::Result) -> Int\n\nReturn the number of rows in the query result. This will be 0 if the query would never return data.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.prepare-Tuple{LibPQ.Connection,AbstractString}",
    "page": "API",
    "title": "LibPQ.prepare",
    "category": "Method",
    "text": "prepare(jl_conn::Connection, query::AbstractString) -> Statement\n\nCreate a prepared statement on the PostgreSQL server using libpq. The statement is given an generated unique name using unique_id.\n\nnote: Note\nCurrently the statement is not explicitly deallocated, but it is deallocated at the end of session per the PostgreSQL documentation on DEALLOCATE.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.reset!-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.reset!",
    "category": "Method",
    "text": "reset!(jl_conn::Connection; throw_error=true)\n\nReset the communication to the PostgreSQL server. The PGconn object will be recreated using identical connection parameters.\n\nSee handle_new_connection for information on the throw_error argument.\n\nnote: Note\nThis function can be called on a connection with status CONNECTION_BAD, for example, but cannot be called on a connection that has been closed.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.reset_encoding!-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.reset_encoding!",
    "category": "Method",
    "text": "reset_encoding!(jl_conn::Connection, encoding::String)\n\nReset the client encoding for the current connection to jl_conn.encoding.\n\nSee also: encoding, set_encoding!\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.server_version-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.server_version",
    "category": "Method",
    "text": "server_version(jl_conn::Connection) -> VersionNumber\n\nGet the PostgreSQL version of the server.\n\nSee 33.2. Connection Status Functions for information on the integer returned by PQserverVersion that is parsed by this function.\n\nSee @pqv_str for information on how this packages represents PostgreSQL version numbers.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.set_encoding!-Tuple{LibPQ.Connection,String}",
    "page": "API",
    "title": "LibPQ.set_encoding!",
    "category": "Method",
    "text": "set_encoding!(jl_conn::Connection, encoding::String)\n\nSet the client encoding for the current connection (see Table 23.1. PostgreSQL Character Sets for possible values).\n\nCurrently all Julia connections are set to use UTF8 as this makes conversion to and from String straighforward. Other encodings are not explicitly handled by this package and will probably be very buggy.\n\nSee also: encoding, reset_encoding!\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.status-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.status",
    "category": "Method",
    "text": "status(jl_conn::Connection) -> libpq_c.ConnStatusType\n\nReturn the status of the PostgreSQL database connection according to libpq. Only CONNECTION_OK and CONNECTION_BAD are valid for blocking connections, and only blocking connections are supported right now.\n\nSee also: error_message\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.status-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.status",
    "category": "Method",
    "text": "status(jl_result::Result) -> libpq_c.ExecStatusType\n\nReturn the status of a result's corresponding database query according to libpq. Only CONNECTION_OK and CONNECTION_BAD are valid for blocking connections, and only blocking connections are supported right now.\n\nSee also: error_message\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.@pqv_str-Tuple{Any}",
    "page": "API",
    "title": "LibPQ.@pqv_str",
    "category": "Macro",
    "text": "@pqv_str -> VersionNumber\n\nParse a PostgreSQL version.\n\nnote: Note\nAs of version 10.0, PostgreSQL moved from a three-part version number (where the first two parts represent the major version and the third represents the minor version) to a two-part major-minor version number. In LibPQ.jl, we represent this using the first two VersionNumber components as the major version and the third as the minor version.Examplesjulia> pqv\"10.1\" == v\"10.0.1\"\ntrue\n\njulia> pqv\"9.2.5\" == v\"9.2.5\"\ntrue\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.Statement-Tuple{DataStreams.Data.Schema,Type{DataStreams.Data.Row},Bool,LibPQ.Connection,AbstractString}",
    "page": "API",
    "title": "LibPQ.Statement",
    "category": "Method",
    "text": "Statement(sch::Data.Schema, ::Type{Data.Row}, append, connection::Connection, query::AbstractString) -> Statement\n\nConstruct a Statement for use in streaming with DataStreams. This function is called by Data.stream!(source, Statement, connection, query).\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.fetch!-Tuple{Any,LibPQ.Result,Vararg{Any,N} where N}",
    "page": "API",
    "title": "LibPQ.fetch!",
    "category": "Method",
    "text": "fetch!(sink::Union{T, Type{T}}, result::Result, args...; kwargs...) where {T} -> T\n\nStream data to sink or a new structure of type T using Data.stream!. Any trailing args or kwargs are passed to Data.stream!. result is cleared upon completion.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.ConnectionOption",
    "page": "API",
    "title": "LibPQ.ConnectionOption",
    "category": "Type",
    "text": "struct ConnectionOption\n\nA Julia representation of a PostgreSQL connection option (PQconninfoOption).\n\nFields:\n\nkeyword\nThe name of the option\nenvvar\nThe name of the fallback environment variable for this option\ncompiled\nThe PostgreSQL compiled-in default for this option\nval\nThe value of the option if set\nlabel\nThe label of the option for display\ndisptype\nIndicator for how to display the option (see ConninfoDisplay)\ndispsize\nThe size of field to provide for entry of the option value (not used here)\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.ConnectionOption-Tuple{LibPQ.libpq_c.PQconninfoOption}",
    "page": "API",
    "title": "LibPQ.ConnectionOption",
    "category": "Method",
    "text": "ConnectionOption(pq_opt::libpq_c.PQconninfoOption) -> ConnectionOption\n\nConstruct a ConnectionOption from a libpg_c.PQconninfoOption.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.ConninfoDisplay",
    "page": "API",
    "title": "LibPQ.ConninfoDisplay",
    "category": "Type",
    "text": "Indicator for how to display a PostgreSQL connection option (PQconninfoOption).\n\nPossible values are:\n\nNormal (libpq: \"\"): display as is\nPassword (libpq: \"*\"): hide the value of this field\nDebug (libpq: \"D\"): don't show by default\n\n\n\n"
},

{
    "location": "pages/api.html#Base.Distributed.clear!-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "Base.Distributed.clear!",
    "category": "Method",
    "text": "clear!(jl_result::Result)\n\nClean up the memory used by the PGresult object. The Result will no longer be usable.\n\n\n\n"
},

{
    "location": "pages/api.html#Base.close-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "Base.close",
    "category": "Method",
    "text": "close(jl_conn::Connection)\n\nClose the PostgreSQL database connection and free the memory used by the PGconn object. This function calls PQfinish, but only if jl_conn.closed is false, to avoid a double-free.\n\n\n\n"
},

{
    "location": "pages/api.html#Base.isopen-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "Base.isopen",
    "category": "Method",
    "text": "isopen(jl_conn::Connection) -> Bool\n\nCheck whether a connection is open.\n\n\n\n"
},

{
    "location": "pages/api.html#Base.parse-Tuple{Type{LibPQ.ConninfoDisplay},AbstractString}",
    "page": "API",
    "title": "Base.parse",
    "category": "Method",
    "text": "parse(::Type{ConninfoDisplay}, str::AbstractString) -> ConninfoDisplay\n\nParse a ConninfoDisplay from a string. See ConninfoDisplay.\n\n\n\n"
},

{
    "location": "pages/api.html#Base.show-Tuple{IO,LibPQ.Connection}",
    "page": "API",
    "title": "Base.show",
    "category": "Method",
    "text": "show(io::IO, jl_conn::Connection)\n\nDisplay a Connection by showing the connection status and each connection option.\n\n\n\n"
},

{
    "location": "pages/api.html#Base.show-Tuple{IO,LibPQ.Result}",
    "page": "API",
    "title": "Base.show",
    "category": "Method",
    "text": "show(io::IO, jl_result::Result)\n\nShow a PostgreSQL result and whether it has been cleared.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_oids-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.column_oids",
    "category": "Method",
    "text": "column_oids(jl_result::Result) -> Vector{LibPQ.Oid}\n\nReturn the PostgreSQL oids for each column in the result.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.column_types-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.column_types",
    "category": "Method",
    "text": "column_types(jl_result::Result) -> Vector{Type}\n\nReturn the corresponding Julia types for each column in the result.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.conninfo-Tuple{AbstractString}",
    "page": "API",
    "title": "LibPQ.conninfo",
    "category": "Method",
    "text": "conninfo(str::AbstractString) -> Vector{ConnectionOption}\n\nParse connection options from a connection string (either a URI or key-value pairs).\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.conninfo-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.conninfo",
    "category": "Method",
    "text": "conninfo(jl_conn::Connection) -> Vector{ConnectionOption}\n\nGet all connection options for a connection.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.error_message-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.error_message",
    "category": "Method",
    "text": "error_message(jl_conn::Connection) -> String\n\nReturn the error message most recently generated by an operation on the connection. Includes a trailing newline.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.error_message-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.error_message",
    "category": "Method",
    "text": "error_message(jl_result::Result) -> String\n\nReturn the error message associated with the result, or an empty string if there was no error. Includes a trailing newline.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.handle_new_connection-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.handle_new_connection",
    "category": "Method",
    "text": "handle_new_connection(jl_conn::Connection; throw_error=true) -> Connection\n\nCheck status and handle errors for newly-created connections. Also set the client encoding (23.3. Character Set Support) to jl_conn.encoding.\n\nIf throw_error is true, an error will be thrown if the connection's status is CONNECTION_BAD and the PGconn object will be cleaned up. Otherwise, a warning will be shown and the user should call close or reset! on the returned Connection.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.handle_result-Tuple{LibPQ.Result}",
    "page": "API",
    "title": "LibPQ.handle_result",
    "category": "Method",
    "text": "handle_result(jl_result::Result; throw_error::Bool=true) -> Result\n\nCheck status and handle errors for newly-created result objects.\n\nIf throw_error is true, throw an error and clear the result if the query results in a fatal error or unreadable response. Otherwise a warning is shown.\n\nAlso print an info message about the result.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.parameter_pointers-Tuple{AbstractArray{#s211,1} where #s211<:Union{Missings.Missing, String}}",
    "page": "API",
    "title": "LibPQ.parameter_pointers",
    "category": "Method",
    "text": "parameter_pointers(parameters::AbstractVector{<:Parameter}) -> Vector{Ptr{UInt8}}\n\nGiven a vector of parameters, returns a vector of pointers to either the string bytes in the original or C_NULL if the element is missing.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.string_parameters",
    "page": "API",
    "title": "LibPQ.string_parameters",
    "category": "Function",
    "text": "string_parameters(parameters::AbstractVector) -> Vector{Union{String, Missing}}\n\nConvert parameters to strings which can be passed to libpq, propagating missing.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.transaction_status-Tuple{LibPQ.Connection}",
    "page": "API",
    "title": "LibPQ.transaction_status",
    "category": "Method",
    "text": "transaction_status(jl_conn::Connection) -> libpq_c.PGTransactionStatusType\n\nReturn the PostgreSQL database server's current in-transaction status for the connection. See  for information on the meaning of the possible return values.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.unique_id",
    "page": "API",
    "title": "LibPQ.unique_id",
    "category": "Function",
    "text": "unique_id(jl_conn::Connection, prefix::AbstractString=\"\") -> String\n\nReturn a valid PostgreSQL identifier that is unique for the current connection. This is mostly used to create names for prepared statements.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ.unsafe_string_or_null-Tuple{Cstring}",
    "page": "API",
    "title": "LibPQ.unsafe_string_or_null",
    "category": "Method",
    "text": "unsafe_string_or_null(ptr::Cstring) -> Union{String, Missing}\n\nConvert a Cstring to a Union{String, Missing}, returning missing if the pointer is C_NULL.\n\n\n\n"
},

{
    "location": "pages/api.html#LibPQ-API-1",
    "page": "API",
    "title": "LibPQ API",
    "category": "section",
    "text": "DocTestSetup = quote\n    using LibPQ\nendModules = [LibPQ]\nPages = [\"LibPQ.jl\", \"utils.jl\", \"datastreams.jl\"]"
},

]}
